#include "ft_strace.h"

void pr_error(char *function, char *syscall)
{
	fprintf(stderr, "ft_strace: %s: %s: %s.\n", function, syscall, strerror(errno));
	exit(EXIT_FAILURE);
}

int do_child(char **argv)
{
	/* Because we're now a tracee, execvp will block until the parent
	 * attaches and allows us to continue. */
	raise(SIGSTOP);
	if (execvp(argv[1], argv + 1))
		pr_error("do_child", "execvp");
	return 0;
}

int do_trace(pid_t tracee_pid)
{
	/* parent */
	/* sync with execvp */
	if (ptrace(PTRACE_SEIZE, tracee_pid, 0, 0) == -1)
		pr_error("do_trace", "ptrace(PTRACE_SEIZE)");

	if (waitpid(tracee_pid, 0, 0) == -1)
		pr_error("do_trace", "waitpid");

	/*	PTRACE_O_EXITKILL: ???
	 * 	PTRACE_O_TRACESYSGOOD: ???
	 */
	if (ptrace(PTRACE_SETOPTIONS, tracee_pid, 0, PTRACE_O_EXITKILL | PTRACE_O_TRACESYSGOOD) == -1)
		pr_error("do_trace", "ptrace(PTRACE_SETOPTIONS)");

	bool enter_sys = true;
	int signo = 0;
	while (1)
	{
		// Run the process until the next syscall enter or exit
		if (ptrace(PTRACE_SYSCALL, tracee_pid, 0, signo) == -1)
			pr_error("do_trace", "ptrace(PTRACE_SYSCALL)");
		signo = 0;

		// printf("[FT_STRACE PID]: %d\n", getpid());
		int status;
		if (waitpid(tracee_pid, &status, 0) == -1)
			pr_error("do_trace", "waitpid");

		int sig = WSTOPSIG(status);

		/* If child has stopped by a signal */
		// Ignore SIGTRAP signals generated by syscall
		if (WIFSTOPPED(status) && sig != (SIGTRAP | 0x80))
			signo = print_siginfo(tracee_pid);
		else if (WIFSTOPPED(status) && sig == (SIGTRAP | 0x80))
		{
			if (enter_sys)
				print_syscall_entry(tracee_pid);
			else
				print_syscall_exit(tracee_pid);
			enter_sys = !enter_sys;
		}

		if (WIFEXITED(status))
		{
			if (!enter_sys)
				fprintf(stderr, " = ?\n");
			fprintf(stderr, "+++ exited with %d +++\n", WEXITSTATUS(status));
			exit(WEXITSTATUS(status));
		}
		else if (WIFSIGNALED(status))
		{
			if (!enter_sys)
				fprintf(stderr, " = ?\n");
			fprintf(stderr, "+++ killed by %s +++\n", signal_name(WTERMSIG(status)));
			raise(WTERMSIG(status));
		}
	}
	return 0;
}

int main(int argc, char *argv[])
{
	if (argc <= 1)
		fprintf(stderr, "too few arguments: %d", argc);

	pid_t pid = fork();
	if (pid == -1)
		pr_error("main", "fork");
	else if (pid == 0)
		return do_child(argv);
	return do_trace(pid);
}
